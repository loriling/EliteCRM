# 多线程与高并发

- 线程的概念 启动方式 常用方法

  CPU调度与执行的基本单位

  new Thread(), new Runnable(), Executor

  sleep wait join

- synchronized(Object)
  - 不能用String常量 Integer Long
  - “object”

- 线程同步
  - synchronized
    - 锁的是对象不是代码
    - this XX.class
    - 锁定方法 非锁定方法 同时执行
    - 锁升级
      - 偏向锁 （对象的markword上记录了第一个来访问的线程的名字，如果后面还是这个线程则直接使用，如果后面来了其他线程，则进行锁升级，升级到自旋锁）
      - 自旋锁（while循环10次，尝试获取锁，如果10次都没拿到，则再次升级到重量级锁） 
      - 重量级锁（os级别，进入等待队列，不占用cpu时间）

## volatile

- 保证线程可见性

  一个线程中对值的改变，另外一个线程可以马上看到

  MESI 缓存一致性协议

- 禁止指令重排序（CPU）

  - DCL单例
  - Double Check Lock



## CAS(无锁优化 自旋 乐观锁)

- Compare And Set

- cas(V, Expected, NewValue)

  - if V == E

    V  = New

    otherwise  try again or fail

  - CPU原语支持

- ABA问题

  - 加version
  - A 1.0
  - B 2.0
  - C 3.0
  - cas(version)
  - 如果是基础类型，无所谓 ；引用类型可能有问题

Unsafe类（类似C C++的指针）

- 直接操作内存
  - allocateMemory freeMemory putXX pageSize
- 直接生成类实例
  - allocateInstance
- 直接操作类或实例变量
  - objectFieldOffset
  - getInt
  - getObject
- CAS相关操作
  - weakCompareAndSetObject Int Long



## AQS（AbstractQueuedSynchronizer）

为什么说AQS的底层是CAS+volatile 

AQS中有个用volatile修饰的state，和一个由Node组成的双向链表，这个双向链表的进和出都是用的CAS实现的线程安全

- AQS源码
  - VarHandle（JDK1.9之后） -> 1: 普通属性原子操作 2: 比反射快，直接操作二进制码



## ThreadLocal

ThreadLocalMap Entry -》 WeakReference

这个map的key就是ThreadLocal对象本身，value就是set进去的需要存下来的对象

为什么Entry要使用弱引用？

若是强引用，几时tl = null，但是key的应用依然指向ThreadLocal对象，所以会有内存泄漏，而是用弱引用则不会。

但还是有内存泄漏存在，ThreadLocal被回收，key的值变成了null，则导致整个value再也无法被访问到，因此依然存在内存泄漏。这时候就要手动调用tl.remove();



## JAVA中的引用（强软弱虚）

强引用：就是我们平时写的引用类型

软引用（SoftReference）： 当系统内存不够使用时候，就会被垃圾回收

弱引用（WeakReference）：只要遭遇到gc就会被回收，一般用在容器里（WeakHashMap，ThreadLocal），如果有另外一个强引用指向了某个对象，一旦这个强应用清空了，那么这个对象就会被回收了

虚引用（PhantomReference）：管理堆外内存的。给写JVM的人用的，不是一般程序员用的。当被回收时候会收到一个通知。DirectByteBuffer



## 容器

- Vector和Hashtable 自带锁 现在基本不用

- HashMap -> Hashtable -> SynchronizedHashMap -> ConcurrentHashMap

- Vector -> Queue

- ConcurrentHashMap 高并发无序的map  

  - ConcurrentSkipListMap 高并发排序的map（跳表结构，多层链表）

  - CopyOnWriteList 适合读多写少的情况

- BlockingQueue （Queue提供的接口offer（相当于add） poll peek（往外取，poll取完删掉，peek取完不删）） （put take 天生实现了生产者和消费者模型，等待的添加和取出）LinkedBlockingQueue有界 ArrayBlockingQueue无界

  - Queue 和 List的区别

    对线程友好的API offer peek poll

    BlockingQueue

    put take -> 阻塞

  - DelayQueue 按时间进行任务调度

  - PriorityQueue

  - SynchronusQueue 容量为0 手递手交换

  - TransferQueue（transfer方法，阻塞主，直到被取走才会继续下去）多人对多人的手递手