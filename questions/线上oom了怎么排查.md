## 线上oom了怎么排查

这个问题比较宽泛
先说oom涉及到多种类型，包括了：

- heap space堆内存溢出； 
- stack overflow栈溢出；
- non-heap space非堆内存溢出；
- native memory 本地方法内存；
- GC overhead limit exceeded gc溢出；



1. 看服务日志，看是否有相关报错，能不能找到相关oom报错日志，来定位是哪个服务里，哪种内存溢出。
2. 如果是heap space的溢出，那需要检查jvm内存配置，看看是不是配置太小，不够用了，如果配置正常，那么就有可能存在内存泄露。可以尝试通过jmap命令来查看内存使用情况，也可以把heap dump下来，用工具去分析内存里的内容（这个heap dump动作很大，生产环境一般不能直接操作）
   通过分析后，去代码中判断猜测哪里可能存在问题，然后按不同问题去尝试优化和修复。
   常见的内存泄露有（有些不算泄露，只能算不合理的使用）：
   - ThreadLocal的泄露
   - 数据库连接，网络连接，IO连接用完没关闭
   - 静态变量集合存放了太多的内容，用完没有回收
   - 数据库查询出来的大量结果都放到list里
   - 线程池配置问题，造成等待队列满，从而内存溢出
3. 如果是stack overflow，这种就比较好解决，通常是递归时候出现了无限递归造成，比如查找某个树节点的根节点，结果数据有错误，造成多个节点之前相互为对方父节点，造成死循环。
4. 如果是non-heap space：以前jdk6时候有个PermGen内存，就属于非堆内存，jdk8后就变成了Metaspace了，逻辑一样，都是存放加载类之类的数据，jdk6里需要配置PermGen大小，如果不配置，默认大小可能不够，就会造成报错。jdk8里的Metaspace大小默认是不限制的，通常都不会出现这种内存溢出。
5. 如果是native memory则需要找找看代码里调用什么native的方法，这种情况也比较少。
6. 如果是gc相关溢出，那通常就是heap已经被基本耗尽，造成的jvm平凡gc出现，这个和heap space的类似，也要去看为啥内存回收不下来，具体放了哪些东西（很可能就是数据库查询出过多数据）